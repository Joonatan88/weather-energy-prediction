// COMMAND ----------

import org.apache.spark.ml.classification.NaiveBayes
import org.apache.spark.sql.{DataFrame, Row}
import org.apache.spark.sql.types.{StructType, StructField, StringType, DoubleType}
import org.apache.spark.ml.Pipeline
import org.apache.spark.ml.classification.RandomForestClassifier
import org.apache.spark.ml.evaluation.MulticlassClassificationEvaluator
import org.apache.spark.ml.feature.{VectorAssembler, StringIndexer}
import org.apache.spark.sql.functions._
import org.apache.spark.ml.linalg.Vector
import org.apache.spark.sql.functions.udf

//Naive-Bayes model

//Model Creation
def Naive_Bayes(data: DataFrame, features: Array[String], labels: String): (String, String, String, Double, Double, Double, Double) = {

//Splitting data to 80/20
  val Array(trainingData, testData) = data.randomSplit(Array(0.8, 0.2), seed = 1)

//Vectorizing features
  val featureAssembler = new VectorAssembler()
    .setInputCols(features)
    .setOutputCol("features")

//Labeling
  val labelIndexer = new StringIndexer()
    .setInputCol(labels)
    .setOutputCol("indexedLabel")
    .fit(data)

//Declaring model
  val naiveBayes = new NaiveBayes()
    .setFeaturesCol("features")
    .setLabelCol("indexedLabel")

//Pipeline including vectorizer, labeler and our model
  val pipeline = new Pipeline().setStages(Array(featureAssembler, labelIndexer, naiveBayes))

  //Training
  println(s"Training a 'NaiveBayes' model to predict $labels based on inputs: ${features.mkString(" ")}")
  val model = pipeline.fit(trainingData)

  // Make predictions on the test set
  val predictions = model.transform(testData)

  //built-in eval
  val sparkEvaluator = new MulticlassClassificationEvaluator()
    .setLabelCol("indexedLabel")
    .setPredictionCol("prediction")
    .setMetricName("accuracy")
  
  val accuracy = sparkEvaluator.evaluate(predictions)
  println(s"Accuracy: $accuracy")

  //Custom Evaluations
  val correctPredictions = predictions.filter(col("indexedLabel") === col("prediction")).count()
  val totalPredictions = predictions.count()
  val customAccuracy = correctPredictions.toDouble / totalPredictions
  println(s"Custom Accuracy: $customAccuracy")

//Cyclicity fix 
  val cyclicRange = if (labels == "month") 12 else 24

  val oneAway = predictions.filter(row => {
    val label = row.getAs[Double]("indexedLabel")
    val pred = row.getAs[Double]("prediction")
    Math.abs(label - pred) <= 1 || Math.abs(label - pred) == cyclicRange - 1
  }).count().toDouble / totalPredictions

  val twoAway = predictions.filter(row => {
    val label = row.getAs[Double]("indexedLabel")
    val pred = row.getAs[Double]("prediction")
    Math.abs(label - pred) <= 2 || Math.abs(label - pred) >= cyclicRange - 2
  }).count().toDouble / totalPredictions
  
  println(s"Percentage within 1 unit: $oneAway")
  println(s"Percentage within 2 units: $twoAway")

  val extractProbability = udf((probability: Vector, label: Double) => {
    val labelIndex = label.toInt
    probability(labelIndex)
  })

  val predictionsWithProb = predictions.withColumn(
    "correctProbability",
    extractProbability(col("probability"), col("indexedLabel"))
  )

//Calculate average probability for correct predictions
  val avgProbability = predictionsWithProb.agg(avg("correctProbability")).first().getDouble(0)
  println(s"Average Probability for Correct Value: $avgProbability")

//Return model type, input features, label, and evaluation metrics
  ("NaiveBayes", features.mkString(" "), labels, customAccuracy * 100, oneAway * 100, twoAway * 100, avgProbability)
}


// COMMAND ----------
